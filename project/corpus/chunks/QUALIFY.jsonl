{"chunk_id": "9df809f502806d9232aa90a84c7bef8d2d5cb3c3", "doc_id": "commands/QUALIFY.md", "page_title": "QUALIFY", "heading_path": "", "chunk_index": 0, "text": "# QUALIFY\n\nIn a SELECT statement, the QUALIFY clause filters the results of window functions.\n\nQUALIFY does with window functions what HAVING does with aggregate functions and GROUP BY clauses.\n\nIn the logical execution order, QUALIFY is evaluated after window functions are computed. A typical evaluation order:\n\n1. FROM\n2. WHERE\n3. GROUP BY\n4. HAVING\n5. WINDOW (analytic functions)\n6. QUALIFY\n7. DISTINCT\n8. ORDER BY\n9. LIMIT", "approx_tokens": 106}
{"chunk_id": "61485f9c42d5dfd971f079bcdad94744525fcaaa", "doc_id": "commands/QUALIFY.md", "page_title": "QUALIFY", "heading_path": "Syntax", "chunk_index": 0, "text": "## Syntax\n\n    QUALIFY <predicate>\n\nGeneral shape (variations in order are possible but not shown here):\n\n    SELECT <column_list>\n      FROM <data_source>\n      [GROUP BY ...]\n      [HAVING ...]\n      QUALIFY <predicate>\n      [ ... ]", "approx_tokens": 58}
{"chunk_id": "65cddf6a55ff9585533c434c3c2539ca83966b6a", "doc_id": "commands/QUALIFY.md", "page_title": "QUALIFY", "heading_path": "Parameters", "chunk_index": 0, "text": "## Parameters\n\ncolumn_list — As in the SELECT projection rules.\n\ndata_source — A table or table-like source (view, UDTF, etc.).\n\npredicate — Boolean expression evaluated after window functions and aggregates. Can reference window functions and behaves like HAVING (but without the HAVING keyword).", "approx_tokens": 74}
{"chunk_id": "36245de06fc6f088adf5b81976c2c8ed6ec75c0d", "doc_id": "commands/QUALIFY.md", "page_title": "QUALIFY", "heading_path": "Usage notes", "chunk_index": 0, "text": "## Usage notes\n\n- QUALIFY requires at least one window function either in the SELECT list or inside the QUALIFY predicate.\n- Expressions in the SELECT list (including window functions) may be referenced by column alias in QUALIFY.\n- Aggregates and subqueries are allowed inside QUALIFY; aggregate rules mirror those of HAVING.\n- QUALIFY is Snowflake-specific (not ANSI); QUALIFY is a reserved word.", "approx_tokens": 99}
{"chunk_id": "92a105b210e5b6d8f0dff7f6f4b26704990ab946", "doc_id": "commands/QUALIFY.md", "page_title": "QUALIFY", "heading_path": "Translator guidance (LLM-facing)", "chunk_index": 0, "text": "## Translator guidance (LLM-facing)\n\n- If the source filters on a window function in WHERE, move that predicate to QUALIFY.\n- Prefer aliasing window results (e.g., AS rn) and writing QUALIFY rn = 1 for clarity.\n- When translating T-SQL patterns like WHERE ROW_NUMBER() OVER(...) = 1, emit a validator suggestion MOVE_TO_QUALIFY if needed and rewrite with QUALIFY.", "approx_tokens": 90}
{"chunk_id": "e0e4e3a132a034b82eb772cc2ec3eeaecb9b09a2", "doc_id": "commands/QUALIFY.md", "page_title": "QUALIFY", "heading_path": "Examples", "chunk_index": 0, "text": "## Examples\n\nCreate and load a table:\n\n    CREATE TABLE qt (i INTEGER, p CHAR(1), o INTEGER);\n    INSERT INTO qt (i, p, o) VALUES\n        (1, 'A', 1),\n        (2, 'A', 2),\n        (3, 'B', 1),\n        (4, 'B', 2);\n\nNesting instead of QUALIFY:\n\n    SELECT *\n    FROM (\n      SELECT i, p, o,\n             ROW_NUMBER() OVER (PARTITION BY p ORDER BY o) AS row_num\n      FROM qt\n    )\n    WHERE row_num = 1;\n\nUsing QUALIFY:\n\n    SELECT i, p, o\n    FROM qt\n    QUALIFY ROW_NUMBER() OVER (PARTITION BY p ORDER BY o) = 1;\n\nReferencing a SELECT alias from QUALIFY:\n\n    SELECT i, p, o, ROW_NUMBER() OVER (PARTITION BY p ORDER BY o) AS row_num\n    FROM qt\n    QUALIFY row_num = 1;\n\nWith aggregates and a subquery in the predicate:\n\n    SELECT c2, SUM(c3) OVER (PARTITION BY c2) AS r\n    FROM t1\n    WHERE c3 < 4\n    GROUP BY c2, c3\n    HAVING SUM(c1) > 3\n    QUALIFY r IN (\n      SELECT MIN(c1)\n      FROM test\n      GROUP BY c2\n      HAVING MIN(c1) > 3\n    );", "approx_tokens": 237}
