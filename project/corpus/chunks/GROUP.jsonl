{"chunk_id": "4e72c1465de5c3c2f6c72e247e42c83db6b05079", "doc_id": "commands/GROUP.md", "page_title": "GROUP BY", "heading_path": "", "chunk_index": 0, "text": "# GROUP BY\n\nGroups rows with the same group-by-item expressions and computes aggregate functions for each resulting group.\n\nA GROUP BY expression can be:\n- A column name.\n- A number referencing a position in the SELECT list.\n- A general expression.", "approx_tokens": 62}
{"chunk_id": "4a6e27a03ab299032b9b07adcbec68e796e035ea", "doc_id": "commands/GROUP.md", "page_title": "GROUP BY", "heading_path": "Syntax (core)", "chunk_index": 0, "text": "## Syntax (core)\n\n    SELECT <select_list>\n    FROM <table_or_source>\n    [WHERE <predicate>]\n    GROUP BY <group_item> [, <group_item>, ...]\n    [HAVING <aggregate_predicate>]\n    [ORDER BY <expr> [ASC|DESC]]\n    [LIMIT <n>]\n\nWhere a `<group_item>` is:\n- A column reference (e.g., city)\n- A positional index (e.g., 1 for the first projected column)\n- An expression (e.g., DATE_TRUNC('month', ts))", "approx_tokens": 99}
{"chunk_id": "5420e65acc10b21fd848066d5a136665aa54375d", "doc_id": "commands/GROUP.md", "page_title": "GROUP BY", "heading_path": "Usage notes", "chunk_index": 0, "text": "## Usage notes\n\n- Aggregates (e.g., COUNT, SUM, MIN, MAX, AVG) are typically used with GROUP BY.\n- Positional indexes refer to items in the SELECT list (1-based). Use with care for readability.\n- Columns in the SELECT list must be either:\n  - Grouped (appear in GROUP BY), or\n  - Aggregated, or\n  - Functionally dependent when supported by the engine rules.\n- HAVING filters **after** grouping and can only reference grouped columns, aggregates, or expressions derived from them.", "approx_tokens": 119}
{"chunk_id": "2e1aa4b72b12e5643514129de2c6c9024a7c5bce", "doc_id": "commands/GROUP.md", "page_title": "GROUP BY", "heading_path": "Extensions", "chunk_index": 0, "text": "## Extensions", "approx_tokens": 3}
{"chunk_id": "e62249906ed8297e2f603050a9bdb9a69370e289", "doc_id": "commands/GROUP.md", "page_title": "GROUP BY", "heading_path": "Extensions > GROUP BY CUBE", "chunk_index": 0, "text": "### GROUP BY CUBE\n`GROUP BY CUBE` is similar to `GROUP BY ROLLUP` but also adds all “cross-tabulation” rows. A CUBE with N elements corresponds to `2^N` grouping sets.\n\nHigh level:\n- Produces all rollup totals plus every combination of dimensions.\n- Useful for multi-dimensional summaries.", "approx_tokens": 72}
{"chunk_id": "9552e167df47cc2e737d49542144ba61bd75e921", "doc_id": "commands/GROUP.md", "page_title": "GROUP BY", "heading_path": "Extensions > GROUP BY GROUPING SETS", "chunk_index": 0, "text": "### GROUP BY GROUPING SETS\nComputes multiple group-by lists in a single query. Each grouping set is an independent grouping of dimension columns.\n\nEquivalences:\n- `GROUP BY GROUPING SETS (a)` ≈ `GROUP BY a`\n- `GROUP BY GROUPING SETS (a, b)` ≈ `(GROUP BY a) UNION ALL (GROUP BY b)`", "approx_tokens": 70}
{"chunk_id": "8274629e30663b07600dc03ff4ef79c62317f4ac", "doc_id": "commands/GROUP.md", "page_title": "GROUP BY", "heading_path": "Extensions > GROUP BY ROLLUP", "chunk_index": 0, "text": "### GROUP BY ROLLUP\nProduces hierarchical subtotals in addition to grouped rows. Think of it as multiple result levels where each subsequent level aggregates the previous one (e.g., city → state → all).", "approx_tokens": 50}
{"chunk_id": "bd5eff3918a821e2ff1de1863d0d7b65a800cca9", "doc_id": "commands/GROUP.md", "page_title": "GROUP BY", "heading_path": "Examples: CUBE (sales)", "chunk_index": 0, "text": "## Examples: CUBE (sales)\n\nStart by creating and loading a table with information about sales from a chain store that has branches in different cities and states/territories.\n\n    -- Create some tables and insert some rows.\n    CREATE TABLE products (product_ID INTEGER, wholesale_price REAL);\n    INSERT INTO products (product_ID, wholesale_price) VALUES \n        (1, 1.00),\n        (2, 2.00);\n\n    CREATE TABLE sales (product_ID INTEGER, retail_price REAL, \n        quantity INTEGER, city VARCHAR, state VARCHAR);\n    INSERT INTO sales (product_id, retail_price, quantity, city, state) VALUES \n        (1, 2.00,  1, 'SF', 'CA'),\n        (1, 2.00,  2, 'SJ', 'CA'),\n        (2, 5.00,  4, 'SF', 'CA'),\n        (2, 5.00,  8, 'SJ', 'CA'),\n        (2, 5.00, 16, 'Miami', 'FL'),\n        (2, 5.00, 32, 'Orlando', 'FL'),\n        (2, 5.00, 64, 'SJ', 'PR');\n\nRun a cube query that shows profit by city, state, and total across all states. The example below shows a query that has three “levels”:\n- Each city.\n- Each state.\n- All revenue combined.\n\nUse `ORDER BY state, city NULLS LAST` to keep each state’s rollup directly after its cities and to place the grand total at the end.\n\n    -- Example shape (illustrative):\n    -- SELECT state, city, SUM((s.retail_price - p.wholesale_price) * s.quantity) AS profit\n    -- FROM products AS p JOIN sales AS s ON s.product_ID = p.product_ID\n    -- GROUP BY CUBE (state, city)\n    -- ORDER BY state, city NULLS LAST;", "approx_tokens": 362}
{"chunk_id": "64a565c2a33a7f9cb7b5bf8cefc0f28e8b768908", "doc_id": "commands/GROUP.md", "page_title": "GROUP BY", "heading_path": "Examples: GROUPING SETS (nurses)", "chunk_index": 0, "text": "## Examples: GROUPING SETS (nurses)\n\nThese examples use a table of information about nurses with two categories of licenses.\n\n    CREATE OR REPLACE TABLE nurses (\n      ID INTEGER,\n      full_name VARCHAR,\n      medical_license VARCHAR,   -- LVN, RN, etc.\n      radio_license VARCHAR      -- Technician, General, Amateur Extra\n    );\n\n    INSERT INTO nurses\n        (ID, full_name, medical_license, radio_license)\n      VALUES\n        (201, 'Thomas Leonard Vicente', 'LVN', 'Technician'),\n        (202, 'Tamara Lolita VanZant', 'LVN', 'Technician'),\n        (341, 'Georgeann Linda Vente', 'LVN', 'General'),\n        (471, 'Andrea Renee Nouveau', 'RN', 'Amateur Extra');\n\nUse `GROUP BY GROUPING SETS` to compute multiple independent aggregations in a single pass:\n\n    SELECT COUNT(*), medical_license, radio_license\n      FROM nurses\n      GROUP BY GROUPING SETS (medical_license, radio_license);\n\nOutput (illustrative):\n\n    +----------+-----------------+---------------+\n    | COUNT(*) | MEDICAL_LICENSE | RADIO_LICENSE |\n    |----------+-----------------+---------------|\n    |        3 | LVN             | NULL          |\n    |        1 | RN              | NULL          |\n    |        2 | NULL            | Technician    |\n    |        1 | NULL            | General       |\n    |        1 | NULL            | Amateur Extra |\n    +----------+-----------------+---------------+\n\nInterpretation:\n- Rows with NULL in RADIO_LICENSE count by `medical_license` only.\n- Rows with NULL in MEDICAL_LICENSE count by `radio_license` only.", "approx_tokens": 382}
{"chunk_id": "75cab2bf6eb66fa8698602f581279f0b12a8b766", "doc_id": "commands/GROUP.md", "page_title": "GROUP BY", "heading_path": "Examples: ROLLUP (sales)", "chunk_index": 0, "text": "## Examples: ROLLUP (sales)\n\n`ROLLUP` produces hierarchical subtotals (e.g., city → state → grand total).\n\n    SELECT state, city,\n           SUM((s.retail_price - p.wholesale_price) * s.quantity) AS profit \n    FROM products AS p\n    JOIN sales AS s\n      ON s.product_ID = p.product_ID\n    GROUP BY ROLLUP (state, city)\n    ORDER BY state, city NULLS LAST;\n\nIllustrative output:\n\n    +-------+---------+--------+\n    | STATE | CITY    | PROFIT |\n    |-------+---------+--------|\n    | CA    | SF      |     13 |\n    | CA    | SJ      |     26 |\n    | CA    | NULL    |     39 |\n    | FL    | Miami   |     48 |\n    | FL    | Orlando |     96 |\n    | FL    | NULL    |    144 |\n    | PR    | SJ      |    192 |\n    | PR    | NULL    |    192 |\n    | NULL  | NULL    |    375 |\n    +-------+---------+--------+", "approx_tokens": 202}
{"chunk_id": "b6eed8932575bcb8ef1ef23795d8563f8d95b5cf", "doc_id": "commands/GROUP.md", "page_title": "GROUP BY", "heading_path": "Translator guidance (LLM-facing)", "chunk_index": 0, "text": "## Translator guidance (LLM-facing)\n\n- Preserve GROUP BY semantics; avoid inventing columns or grouping keys.\n- When source uses positional references (e.g., `GROUP BY 1, 2`), maintain them only if unambiguous; prefer explicit column names when clarity matters.\n- For T-SQL migrations that simulate `GROUPING SETS` with `UNION ALL`, prefer Snowflake’s `GROUP BY GROUPING SETS` directly.\n- For hierarchical summaries, translate T-SQL multi-step rollups to a single `GROUP BY ROLLUP`.\n- Keep `ORDER BY` consistent with expected subtotal layout; consider `NULLS LAST` for rollups.", "approx_tokens": 144}
